## Урок 6. ООП Дизайн и Solid
Взять реализованный код в рамках семинара 4 и продемонстрировать применение принципов, усвоенных на семинаре.
Нужно в проекте создать файл ReadMe.md отметить участки кода, которые рефакторим, какой принцип применяем и почему.

### SRP (Single responsibility principle).
**Принцип единственной ответственности**, каждый класс должен отвечать только за одну концептуальную задачу. Действия с объектом класса **Student** были сосредоточены в трех разных классах: **StudentVeiw**, **StudenеServis**, **StudentController** каждый из которых отвечает за решение одной задачи,   в первом классе будет происходить только представление данных об объекте класса **Student** , второй отвечает за  действия над объектом класса **Student**, третий отвечает за  взаимодействие с «окружающим миром».
### OCP (Open-closed principle).
**Принцип открытости закрытости**. Программные сущности (классы, модули, функции и т.п.) должны быть открыты для расширения, но закрыты для изменения. Принцип закрытости, в частности, в классе **User** декларации функций закрыты для изменения вынесением в интерфейс, а Принцип открытости заключается в том, что сам класс **User** открыт для расширения.
### LSP (Liskov substitution principle).
**Принцип подстановки Барбары Лисков**. Это означает, что класс, разработанный путем расширения на основании базового класса, должен переопределять его методы так, чтобы не нарушалась функциональность с точки зрения клиента. То есть, если разработчик расширяет класс и использует его в приложении, он не должен изменять ожидаемое поведение переопределенных методов. В нашем примере если какой то алгоритм обрабатывает объекты родительского класса **User** то ему всегда можно подставить объекты дочерних классов **Student** и **Teacher**, так же создан дочерний класс от класса **Teacher**  -  **Professor** (добавляет ученую степень) который наследует весь функционал класса Teacher и может быть подставлен в ArrayList<Teacher>. Демонстрация при запуске **Main.java** (класс **Professor.java**).
### ISP (Interface segregation principle).
**Принцип разделения интерфейсов**. Интерфейсы не следует заставлять брать на себя больше обязанностей, чем им нужно, а также классы не следует заставлять реализовывать интерфейсы с функциями, которые им не нужны. Этот принцип похож на принцип единой ответственности **SRP**,  **SRP** относится к классам, а **ISP** — к интерфейсам. В частности класс **User** имеет три интерфейса для разных задач, **UserController**, **UserService** и **UserVew**, таким образом используются только те методы которые им необходимы, что улучшает код и позволяет лучше поддерживать и расширять его в будущем.
### DIP (Dependency inversion principle).
**Принцип инверсии зависимостей**. Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те, и другие должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций. **В данном коде этот принцип не реализован!** Реализация могла бы выглядеть так, сервис не создается внутри класса а передается параметром конструктора.






